# 学习备忘录 (Learning Memo)

---

### 2025-01-03: 架构重构中的数据结构适配问题

* **问题场景**: 将类别管理从数组结构 `['餐饮', '交通']` 重构为对象结构 `{ expense: [...], income_source: [...] }` 时，Reducer中的业务逻辑未同步更新。
* **典型错误**: `state.findIndex()` → 应该是 `state.expense.findIndex()`  
* **根本原因**: 数据结构变更后，忘记更新所有依赖该结构的代码逻辑。
* **调试技巧**: 重构时要系统性检查所有相关代码，特别是Reducer中的业务逻辑。
* **架构启示**: 
  - 🎯 **渐进式重构策略**: 通过多个Hook暴露不同视图，保持向后兼容，降低重构风险
  - 🔧 **结构变更清单**: 数据结构修改必须同步更新：初始状态 → Action处理逻辑 → Context暴露接口
  - 📝 **测试驱动**: 重构时先写测试或手动验证关键功能，确保行为一致性

---

### 2025-08-07: 全局类别管理与删除保护（Categories）

* 主题: 用 Context + useReducer 管理"类别"的单一事实来源（Single Source of Truth），避免在表单中硬编码。
* 关键点:
  * 用 `CategoriesContext` 提供全局类别列表与增/删/改操作；表单通过该 Context 渲染下拉选项，彻底移除硬编码。
  * 用 `useMemo` 从 `ExpensesContext` 和 `BudgetsContext` 派生"在用类别集合"，作为删除保护判断依据（有支出记录或任一月份预算非 null 即视为在用）。
  * 用 `useCallback` 稳定化设置/删除/重命名的事件处理器，配合 `React.memo` 降低无关渲染。
  * UI 规则：在设置页显示每个类别的使用计数与删除按钮；若在用则禁用删除并给出原因提示。
  * 渐进式演进：当前继续使用"名称即标识"的字符串模型；如需重命名，再统一迁移 `expenses` 与 `budgets` 中的引用。统一持久化留到"里程碑 10"。

---

本文档用于自动记录在构建 "Expense & Budget SPA" 过程中遇到的关键知识点、最佳实践和重要概念，以便于学习沉淀和未来回顾。

每条记录都会包含日期、主题、以及具体的知识点或感悟。

---

### 2024-07-28: 项目启动与规划

*   **知识点:** **结构化项目规划的重要性**
*   **感悟:** 在编写任何代码之前，通过创建产品需求文档 (PRD) 和详细的任务清单 (Tasks)，可以极大地提高开发效率和项目成功率。
    *   **PRD (`doc/PRD.md`)** 的作用是定义"做什么"(What) 和"为什么做"(Why)，它统一了我们对项目范围和目标的认知。
    *   **任务清单 (`doc/Tasks.md`)** 的作用是定义"怎么做"(How)，它将宏大的目标分解为可管理、可执行的小步骤，让每一步都清晰可见。
*   **最佳实践:** 先规划，后编码。一个清晰的路线图远比仓促开始写代码更有价值。

---

### 2024-07-28: useReducer 状态管理设计

*   **知识点:** **useReducer vs useState 的选择标准**
*   **核心概念:** 
    *   **useState**: 适合简单状态 (字符串、数字、布尔值、简单对象)
    *   **useReducer**: 适合复杂状态管理，特别是当状态变更逻辑复杂、有多种操作类型、或下一个状态依赖于前一个状态时
*   **设计模式:** 
    *   **Action 类型常量化**: 使用 `EXPENSE_ACTIONS` 对象管理所有 action 类型，避免字符串拼写错误
    *   **不可变性原则**: 永远返回新的状态对象，不直接修改原状态
    *   **数据结构设计**: 考虑完整的数据生命周期 (创建时间、修改时间、唯一标识)
*   **最佳实践:** 
    *   在 reducer 中集中处理所有状态变更逻辑，保证状态变更的可预测性
    *   使用辅助函数 (如 `_generateId`) 处理重复逻辑，保持 reducer 的简洁性
    *   详细的注释和数据结构文档有助于代码维护
*   **代码审查收获:**
    *   数组操作要格外小心：`[...state, newItem]` vs `[state, ...newItem]` 结果完全不同
    *   `map()` 返回数组，不需要额外包装：`state.map()` ✅ vs `[state.map()]` ❌
    *   严格比较 (`===`) 比宽松比较 (`==`) 更安全，避免意外的类型转换 

---

### 2025-08-10: 任务5.2 - 动态类别管理落地要点
* **目标**: 移除表单中的硬编码类别，改用 `useCategories()` 作为单一数据源；在 reducer 层提供默认类别种子。
* **实施清单**:
  - 在 `src/context/categoriesReducer.js` 用默认类别初始化 `initialState`（餐饮、交通、购物、娱乐、医疗、教育、其他）。
  - 在 `src/components/ExpenseForm.jsx` 与 `src/components/BudgetForm.jsx` 使用 `useCategories()` 获取选项，替换本地常量。
  - 选择值保护：当所选类别在全局列表中不存在时，回退为 `''` 并提示。
* **相关 Hook 与优化点**: 事件处理用 `useCallback` 稳定引用；删除保护与“在用类别集合”推导放到后续设置页（可用 `useMemo` 从收支/预算派生）。
* **注意**：持久化统一在里程碑10处理，当前只做内存架构与表单一致性。